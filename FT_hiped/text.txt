HIPED:
Crypto Providers:- 
Hiped supports multiple crypto providers. These can be configured using the PROVIDER property 



BC or Bouncy Castle:- This is a pure java crypto provider. It also supports PGP encryption & cipher streams for stream data protection. 

OPENSSL:- uses openssl native library for data protection. 
It doesn't support the HKDF algorithm OR PGP encryption. So, when using CryptoService(Hiped classic), BC is used for working key computation, even if provider is set to OPENSSL. 
Default JCE crypto provider:- This is supported only for CipherStream operations getInputCipherStream() & getOutputCipherStream() in CryptoService, CryptoServiceNG


For OPENSSL follow native library installation instructions in Server Configuration and Installation - HIPED



Features supported for different crypto providers
The features not listed in following grid are available in all providers




PGP	Y	N
N
Format Preserving Encryption(FPE)	Y	Y	N
cipherstreams	Y	N
Y
Hash	Y	N
N
AES (ECB, CBC, CTR, GCM with AEAD)	Y	Y	N
TDES (ECB & CBC)	Y	Y	N
JUICE padding

Y	Y	N
PKCS7, NOPADDING	Y	Y	N
ZERO, ISO78164, ISO101262, X923 padding


Y	N	N
Persistent Key Caching (in files)	Y	Y	N
AES SIV	Y	Y	N


Y- Supported

N - Not Supported

Key Management Features
Key Creation
Completely go through HiPED SDK#KeyManagement before proceeding with key creation using HiPED

CryptoServicePGP.createKeyPair(), - Available only for CBIS KMS

CryptoServiceNG.createrKey(), 

KeyBasedCryptoHash.createRootKey()

CryptoService.createRootKey()





Get key attribute information for a symmetric key/keyset:-
The method getKeyInfo() in classes com.aexp.sec.ssaashiped.crypto.CryptoService and com.aexp.sec.ssaashiped.crypto.ng.CryptoServiceNG , returns the deactivation date, suspend date, key length & algorithm for a symmetric key identifier, from configured key store.   

The method getKeysetInfo() in classes com.aexp.sec.ssaashiped.crypto.CryptoService and com.aexp.sec.ssaashiped.crypto.ng.CryptoServiceNG , returns the deactivation date, suspend date, key length & algorithm for a symmetric keyset identifier, from configured key store.  



Refer to HiPED SDK-> Key States to understand the key life cycle and how keys are activated/deactivated





Key Caching 
Refer HiPED Features#KeyCaching to understand how HiPED caches & refreshes the crypto keys. Go through this section to understand any specific considerations for java HiPED users

Cache cleanup
Applications can remove all cached keys from in memory cache or file cache, using the method.


Utility.cleanupCache()

Key Refresh
Application doesn't need to do anything to ensure that HiPED periodically refreshes the keys in cache. That is default behaviour of the SDK. 

To ensure that the application sees errors encountered during key refresh operation, it is necessary to turn on ERROR logging for com.aexp.sec.commonutil package using log4j configuration, as these errors would be encountered on a background thread. These cannot be thrown back to calling applications. They can only be logged in application log. 

Prefetch
 Calling prefetch methods during application startup or after a cache cleanup ensures that the first crypto operation will not be slow.

CryptoServiceNG.prefetchKeys(),
KeyBasedCryptoHash.prefetchKeys()
CryptoService.prefetchKeys()
CryptoServicePGP.prefetchKeys()
CryptoFPE.prefetchKeys()
To reduce load on KMS servers, when prefetching multiple keys on multiple nodes at the same time, applications should prefetch KMS keys sequentially instead of in parallel using KEY_PREFETCH_SEQUENTIAL_DELAY_MS property. Find the details in CONFIGURATION section below

Refer Get Started with HIPED page and relevant subpages under it for usage sample 

File Cache
This mode of caching is NOT recommended for most applications. Should be used only after consultation with EDPP, if there is proper justification for caching the keys in file system. 

For Big data applications and some console applications, that cannot make use of keys cached in memory, as the memory gets recycled often, keys may be cached in a persistent store like files or distributed cache like redis cache. 

Salient features of hiped file caching:- 

If multiple processes, using the same cache, make concurrent requests to get key from backend, only 1 request goes to backend while other processes wait for that request to complete. 
Protects & saves key data as XML in the persistent cache store.
Configurable, using properties. 
File cache protection.There are 2 options available to protect the file cache:- 
X.509 certificate (RSA).
When using KMS V2(CBIS credentials), the CBIS credentials can be used to protect file cache. 
Allows persisting the XML in a store of user's choice.
Limitations:-
If file caching is enabled for any key store in the application, it must be enabled with exactly the same properties for all other key stores also
Only applications using single KMS V2 key store can use CBIS credentials to protect the file cache. All other applications must procure an X.509 certificate for this purpose


Steps to enable file caching in application


Reconfigure applications using X.509 certificates to use CBIS credentials for protecting file cache
Applications currently using X.509 certificate to protect the file cache can start using CBIS credentials to protect it by following these steps:- 

DO not pass any CS_* properties when configuring HiPED classes. 
Retain all other code and configuration for file caching
Delete the existing file cache forcing cache protection with CBIS credentials


Various Crypto Operations supported by HIPED


Encrypt/Decrypt using Format Preserving Encryption
Interface CryptoFPEProvider Implemented by class CryptoFPE

Refer HiPED features#Encrypt/DecryptusingFormatPreservingEncryption

Refer CryptoFPE -Usage for code snippets. 

Encrypt/decrypt with Vormetric key (HipedNG)
Interface: CryptoServiceNGProvider Implemented by class CryptoServiceNG

Refer HiPED features#Encrypt/decryptwithVORMETRICkey(HiPEDNG)

Can import working keys from the CryptoServiceProvider, to support interoperability between data encrypted/hashed with CryptoServiceProvider
Use method CryptoService.importWKInCKMS()
Can import symmetric keys from third parties into KMS. 
Use method CryptoServiceNG.importKeyInCKMS()
Supports stream encryption, only with AES CTR NoPad algorithm. Methods available to return cipher streams.  Data being written to/read from these cipher streams is automatically encrypted/decrypted. 
Good for cases where data to be streamed is to be protected.
Refer CryptoServiceNG - Usage for code snippets

Nemo applications please refer CryptoService/CryptoServiceNG/KeyBasedCryptoHash Usage

Encrypt/Decrypt with Working Keys (Hiped Classic)
Interface: CryptoServiceProvider Implemented by class CryptoService

Refer HiPED features#Encrypt/DecryptwithWorkingKeys(HiPEDClassic) for feature details

Supports stream encryption, only with AES CTR NoPad algorithm. Methods available to return cipher streams.  Data being written to/read from these cipher streams is automatically encrypted/decrypted. 
Good for cases where data to be streamed is to be protected.

Refer CryptoService - Usage for code snippets

Nemo applications please refer CryptoService/CryptoServiceNG/KeyBasedCryptoHash Usage

PGP Encryption
Interface CryptoServicePGPProvider, Implemented by class CryptoServicePGP

Refer HiPED features#PGPEncryption for feature details

Refer CryptoServicePGP - Usage for code snippets

Nemo applications please refer CryptoServicePGP - Usage

Uses only Bouncy Castle as crypto engine. It doesn't use OPENSSL crypto engine.  The PROVIDER configuration property, even if set by the application, is ignored by PGP classes.

Support for 256-bit AES encryption may require installation/download/enablement of JCE Unlimited Strength Policy, with Oracle JDKs.

Support file processing in 2 modes:

Full files are processed by Bouncy Castle library. The same method takes care of sign/verification after data encrypt/decrypt operation
PGP Cipher Stream is returned to application. Data written to cipher stream is automatically encrypted & data read from cipherstreams is automatically decrypted. If sign/verify is desired, a separate method must be called at the end of read/write operation. 
Provides a method isPGPEncrypted() which returns a boolean indicating whether the input file data is PGP encrypted or not. 

Provides overloads to decrypt/verify which can discover the encryption/signing key id in 2 ways: either from the PGP cipher or can be explicitly provided by user in the decrypt method call

Provides a method exportPGPPublicKey() to export the public key part of the PGP key pair, as an ASCII armored file, to be shared with SFT / gnupg, for public key exchange. 

Provides methods to get the PGP Hex key Id(that is embeded in the PGP ciphers), for a given KMS PGP public key identifier

To avoid tracking the key id, decrypting/verifying application can rely on HiPED to determine the key id from protected payload. They can prefetch all the encryption keys used in the application, so that a map is built in the cache between keys in cache and the PGP key id embedded in the PGP cipher. This allows hiped to discover the PGP private/public key, from the key id embedded in the PGP cipher. Check buildPGPKMSKeyIdMap usage in CryptoServicePGP - Usage



Hash
Interface HashProvider Implemented by class KeyBasedCryptoHash

Refer HiPED features#Hash for feature details

Can import working keys used by the hash() method into KMS, so that hashNG method can also use the same working key value to compute the hash. 
 Use method importWKInCKMS()

Refer KeyBasedCryptoHash - Usage for code snippets

CONFIGURATION


The following settings may be configured in a properties file to configure CryptoService/CryptoServiceNG/KeyBasedCryptoHash instances. Alternately, these settings may be passed as a Properties object to configure CryptoService/CryptoServiceNG/KeyBasedCryptoHash instances.

  If the Configuration file contains the ClientSecret used to authenticate with Apigee KMS service, or the PIN to authenticate with VORMETRIC AGENT, then the Configuration file should be saved in a secured location (folder) and protected by restricting the access only to an Authorized Service ID and the Administrators.                 



 Name  	Operation/KeyStore	 Type  	 Required  
Y/N  

  Description  	
Validation

  	
Default

  
Name

All	
String

Y

Indicates the Configuration Name

Should not be null

 NA

ENVIRONMENT	All	String	Yes, for Custom Keystore like Nemo	
Indicates the environment in which application is deployed like E1, E2 or E3.

set to TEST for test mode.

 

Should be a valid name, according to the Environment enumeration	E3
PROVIDER	All	 String	 N	
 The provider/crypto engine that enables crypto operations.






Valid Values are

BC

OPENSSL

For local testing always use BC as the value(For Hiped 6.2.0 or above)

OPENSSL
SO_FILE_PATH

OPENSSL provider	
String

N

Complete absolute path to the folder containing .so files required by hiped. All required .so file(s) must be present in this folder



Alternative:- Can be set to Period (.) if so files are to be read from the resource stream. Eg:-

SO_FILE_PATH=.

This may not work on all platforms. So, test it thoroughly.

Should not be null, if using openssl provider



 NA

KEY_IDENTIFIER	
CryptoService, CryptoServiceNG, 

CryptoFPE

and KeyBasedCryptoHash classes

String	N	
The default Key identifier to be used by CryptoService, CryptoServiceNG and KeyBasedCryptoHash classes to encrypt/decrypt/hash data.



This can be overridden by specifying another key identifier in the keyHandle/keyHandleNG parameter when making an encrypt/decrypt/hash call.

If this property isn't set, then it is mandatory to provide key identifier when making a crypto call using hiped classes



This default is not used by CryptoEmbed or CryptoServicePGP



Must not be null or empty, if present	NA
KMS_APP_CAR_ID	All	String	Y	CAR id of your application	Must not be null or empty if accessing CKMS using KMS CBIS REST API	
KMS_CBIS_ENDPOINT

KMS CBIS key store- v2	String	N	
If you requested CBIS access for "1e4720ed-5786-4649-907d-a158d62cb6b4" (NEW EAG URL) then. refer this wiki page,

KMSV2 EAG Integration 

* E1: https://eag-dev.aexp.com/security/digital/v2/kms
* E2: https://eag-qa.aexp.com/security/digital/v2/kms

* E2-IDL: https://eag-qa.in.aexp.com/security/digital/v2/kms
* E3: https://eag.aexp.com/security/digital/v2/kms

* E3-IDL: https://eag.in.aexp.com/security/digital/v2/kms



(LEGACY)

The appropriate Kms service endpoint for server environment

If you requested CBIS access for "a78c7ef6-3444-3b8f-93c5-aaf8ce305de9" (legacy) then, 
* E1: https://securityapi-dev.aexp.com/kms/v2
* E2: https://securityapi-qa.aexp.com/kms/v2
* E2-IDL: https://securityapi-qa-ind1.phx.aexp.com/kms/v2
* E3: https://securityapi.aexp.com/kms/v2

* E3-IDL: https://securityapi.igdha-ind.aexp.com/kms/v2



 



Must not be null or empty if accessing CKMS using KMS CBIS REST API	
KMS_CBIS_CLIENT_ID

KMS CBIS key store- v2

String	N	
The client Id obtained after onboarding with KMS CBIS service.



If application is integrated with Hashicorp vault, change the value of this property to specify that actual value should be picked from hashicorp secrets file at runtime


KMS_CBIS_CLIENT_ID=$HASHICORP_VAULT:<keyname in the hashicorp secret file>

 

Eg:- KMS_CBIS_CLIENT_ID=$HASHICORP_VAULT:hc.cbis.id, where hc.cbis.id is actual value of CBIS secret,configured in hashicorp by the application, and maps to actual value of CBIS id

Must not be null or empty if accessing CKMS using KMS CBIS REST API	
KMS_CBIS_CLIENT_SECRET

KMS CBIS key store- v2

String	N	
The client secret obtained after onboarding with KMS CBIS service

If application is integrated with Hashicorp vault, change the value of this property to specify that actual value should be picked from hashicorp secrets file at runtime


KMS_CBIS_CLIENT_SECRET=$HASHICORP_VAULT:<keyname in the hashicorp secret file>

 

Eg:- KMS_CBIS_CLIENT_SECRET=$HASHICORP_VAULT:hc.cbis.secret, where hc.cbis.secret is configured in hashicorp by the application, and maps to actual value of CBIS secret

Must not be null or empty if accessing CKMS using KMS CBIS REST API	
KMS_CBIS_TOKEN_ENDPOINT

KMS CBIS key store- v2

String	N	
The endpoint used to generate CBIS token for user authentication
*E1: 

https://oneidentityapi-dev.aexp.com/security/digital/v1/application/token
*E2: 

https://oneidentityapi-qa.aexp.com/security/digital/v1/application/token
*E2-IDL: 

https://oneidentityapi-qa.in.aexp.com/security/digital/v1/application/token
*E3: 

https://oneidentityapi.aexp.com/security/digital/v1/application/token

*E3-IDL:
https://oneidentityapi.in.aexp.com/security/digital/v1/application/token

* Check with (IDaaS)CBIS team in case of any issues with the endpoint, as this service is supported by them

Must not be null or empty if accessing CKMS using KMS CBIS REST API	
HASHICORP_SOURCE_PATH	Hashicorp integration	String	N	
If application is integrated with hashicorp and needs to read hiped properties from the hashicorp vault, set this property to absolute path to the file containing secrets pushed by the hashicorp vault to your server

 

Any secret/sensitive hiped property value can be uploaded to hashicorp vault by application. Hiped will read the property value from vault, if the sensitive property value has the following pattern, instead of actual value:-

$HASHICORP_VAULT:<keyname in the hashicorp secret file>

Check the property KMS_CBIS_CLIENT_ID for an example




/opt/epaas/vault/secrets/secrets

SSL_TRUSTSTORE_PATH

custom truststore for Key store REST API access	String	N	Absolute path to the custom truststore containing CA certificate for the APIGEE/CBIS endpoint(s)	

SSL_TRUSTSTORE_PWD

custom truststore for Key store REST API access	String	N	Password for the truststore. This can be entered in the hashicorp vault, if application is integrated with hashicorp	

KMS_APIGEE_SVC_ENDPOINT	KMS APIGEE key store- v1	 String	N	 The appropriate Kms service endpoint for server environment
E1:https://eag-dev.aexp.com/security/digital/v1/ssaas_kms

E2: https://eag-qa.aexp.com/security/digital/v1/ssaas_kms

E2-IDL: https://eag-qa.aexp.com/security/digital/v1/ssaas_kms

E3: https://eag.aexp.com/security/digital/v1/ssaas_kms

E3-IDL: https://eag.in.aexp.com/security/digital/v1/ssaas_kms

 Must not be null or empty if accessing CKMS using KMS APIGEE REST API	 NA
KMS_APIGEE_CLIENT_ID	KMS APIGEE key store- v1
 String	 N	
The clientId obtained after onboarding with KMS Apigee service.

If application is integrated with Hashicorp vault, change the value of this property to specify that actual value should be picked from hashicorp secrets file at runtime


KMS_APIGEE_CLIENT_ID=$HASHICORP_VAULT:<keyname in the hashicorp secret file>

 

Eg:- KMS_APIGEE_CLIENT_ID=$HASHICORP_VAULT:hc.apigee.id, where hc.apigee.id is configured in hashicorp by the application, and maps to actual value of APIGEE id

 Must not be null or empty if accessing CKMS using KMS APIGEE REST API	 NA
KMS_APIGEE_CLIENT_SECRET	KMS APIGEE key store- v1
 String	 N	The client secret obtained after onboarding with KMS Apigee service


If application is integrated with Hashicorp vault, change the value of this property to specify that actual value should be picked from hashicorp secrets file at runtime


KMS_APIGEE_CLIENT_SECRET=$HASHICORP_VAULT:<keyname in the hashicorp secret file>

 

Eg:- KMS_APIGEE_CLIENT_SECRET=$HASHICORP_VAULT:hc.apigee.secret, where hc.apigee.secret is configured in hashicorp by the application, and maps to actual value of APIGEE secret

Must not be null or empty if accessing CKMS using KMS APIGEE REST API	 NA
PGP_ARMOR	CryptoServicePGP	Boolean	N	if output stream has to be ASCII encoded.
Used only for encrypt operation.

true/false	true
PGP_COMPRESSION_TYPE	CryptoServicePGP	String	N	
 If data is to be compressed before encryption.

Used only for encrypt operation

should be one of

ZIP/ UNCOMPRESSED/ BZIP2/ ZLIB

ZIP
PGP_DEC_PRIVATE_KEY_ID	CryptoServicePGP	String	N	The KeyIdentifier corresponding to PGP private key to be used for decryption.	
Should not be null or empty, if property is present

must be an alphanumeric string with length between 5 and 16(both inclusive)



N/A
PGP_ENC_PUB_KEY_ID	CryptoServicePGP	String	N	The KeyIdentifier corresponding to PGP public key to be used for encryption.	
Should not be null or empty, if present.

For KMS, must be in format Appid.KeyId, where both AppId and KeyId are alphanumeric strings. KeyId length between 5 and 16(both inclusive). AppId length > 5

For other keystores, must be an alphanumeric string with length between 5 and 16(both inclusive)

N/A
PGP_INTEGRITY_CHECK

CryptoServicePGP	Boolean	N	
enable integrity check in encrypted data.

Used only for encrypt operation

true/false	true
PGP_SIGN_PRIVATE_KEY_ID	CryptoServicePGP	String	N	
The KeyIdentifier corresponding to PGP private key to be used for signing.



Should not be null or empty, if property is present
must be an alphanumeric string with length between 5 and 16(both inclusive)

N/A
PGP_VERIFY_PUB_KEY_ID	CryptoServicePGP	String	N	The KeyIdentifier corresponding to PGP public key to be used for signature verification.	Should not be null or empty, if property is present
For KMS, must be in format Appid.KeyId, where both AppId and KeyId are alphanumeric strings. KeyId length between 5 and 16(both inclusive). AppId length > 5

For other keystores, must be an alphanumeric string with length between 5 and 16(both inclusive)

N/A
PGP_REMOTE_APP_ID
CryptoServicePGP	String	N	
Comma separated list of remote application ids(The developer app id shared with COPS team during CKMS Onboarding)

If you need to access a PGP public key owned by another application, the other application's apigee/cbis application id must be included in this comma separated list to allow the remote key access.

Must not be null or empty if PGP public keys belonging to another application are to be accessed for encrypting data	N/A
KEY_PREFETCH_SEQUENTIAL_DELAY_MS	All	String	N	
This property allows prefetch of keys in sequential mode in a blocking call. Sequential key prefetches reduce load on KMS servers for applications that prefetch multiple keys on multiple nodes at the same time. It will increase the total time taken for prefetch though. 


If the property is present with a valid value(1 to 120000 milliseconds) then sequential execution takes place with the provided value as time delay between 2 consecutive executions.

By default, when the property is not present, Hiped prefetches keys parallelly on 5 concurrent threadsle threads

1 to 120000 millisecond	N/A




Refer to HIPED features - Nemo for configuration properties to be used with Nemo key store



Enumerations
com.aexp.sec.ssaashiped.crypto.ng.EncryptionAlgorithmsNG   (Applicable only for CryptoServiceNG and CryptoEmbed)
Encryption Algorithms enumeration provides the list of the implemented encryption algorithms. The algorithm name consists of the following 3/4 parts:

1st Part – Encryption Algorithm
2nd Part – Cipher Mode
3rd Part – Padding
4th Part(optional) –JUICE : indicates whether this is JUICE compatible algorithm or not. This part is optional and is present only for JUICE compatible algorithms.
JUICE compatible means, using these algorithms and JUICE keys, HIPED can be used to decrypt data previously encrypted with JUICE. 

 JUICE compatible algorithms are already marked as deprecated, as we strongly recommend moving away from the JUICE keys & recommend re-keying JUICE encrypted data. These algorithms have been provided only for sake of backward compatibility with JUICE



Example Algorithm Name - AES-ECB-NOPAD-JUICE
                                                1        2         3          4

In the above example,

1st Part represents – AES encryption algorithm
2nd Part represents – CTR cipher mode
3rdPart represents – No Padding
4th Part represents – JUICE compatible 




Currently Implemented Encryption Algorithms

The following encryption algorithms are implemented:                 

  Encryption Algorithm  	Notes
AES_CTR_NOPAD	
AES_GCM_NOPAD	
AES_CBC_PKCS7	
AES_ECB_PKCS7	
TDES_CBC_PKCS7	


TDES_ECB_PKCS7	


AES_ECB_NOPAD_JUICE	Deprecated! Compatible with JUICE AES ECB
TDES_CBC_PKCS7_JUICE	
Deprecated! Compatible with JUICE TDEC CBC

TDES_ECB_NOPAD_JUICE	
Deprecated! Compatible with JUICE TDEC ECB







com.aexp.sec.ssaashiped.crypto.EncryptionAlgorithms (Applicable For CryptoService only)
Encryption Algorithms enumeration provides the list of the implemented encryption algorithms. The algorithm name consists of the following 4 parts:

1st Part – Encryption Algorithm
2nd Part – Cipher Mode
3rd Part – Padding
4th Part –Key Length 
 
 There is no default Key Size. The key size is embedded in the Encryption Algorithm enum values. One of the Encryption Algorithm should be configured by the Application in the Properties file/or as a Constructor parameter. Refer to the section Currently Implemented Encryption Algorithms for the currently implemented algorithms.

Example Algorithm Name - AES_CTR_NOPAD_256
                                                1        2         3          4

In the above example,

1st Part represents – AES encryption algorithm
2nd Part represents – CTR cipher mode
3rdPart represents – No Padding
4th Part represents – 256 bit key length


Currently Implemented Encryption Algorithms

Currently, only the following encryption algorithms are implemented:                 

  Encryption Algorithm  
AES_CTR_NOPAD_128
AES_GCM_NOPAD_128
AES_CBC_PKCS7_128
AES_ECB_PKCS7_128
TDES_CBC_PKCS7_128
TDES_ECB_PKCS7_128
AES_CTR_NOPAD_256
AES_GCM_NOPAD_256
AES_CBC_PKCS7_256
AES_ECB_PKCS7_256
TDES_CBC_PKCS7_192
TDES_ECB_PKCS7_192


com.aexp.sec.commonutil.crypto.pgp.EncryptionAlgorithmsPGP (Applicable For PGP only)
EncryptionAlgorithmsPGP enumeration provides the list of the implemented encryption algorithms for PGP. The algorithm name consists of the following 2 parts:

1st Part – Encryption Algorithm
2nd Part – Key Length
Example Algorithm Name - AES_128
                                                1        2 

In the above example,

1st Part represents – AES encryption algorithm
2nd Part represents – 128 bit key length
Currently, only the following encryption algorithms are implemented:    

AES_128
AES_256
TDES
com.aexp.sec.commonutil.crypto.pgp.HashAlgorithmsPGP (Applicable For PGP only)
HashAlgorithmsPGP enumeration provides the list of the implemented hash algorithms. The algorithm name consists of the following 2 parts:

1st Part – Hash Algorithm
2nd Part – Key Length
Example Algorithm Name - SHA_256
                                                1        2 

In the above example,

1st Part represents – Hash algorithm
2nd Part represents – 256 bit key length
Currently, only the following hash algorithms are implemented:  

SHA_256
SHA_384
SHA_512
com.aexp.sec.commonutil.crypto.pgp.CompressionType
ZIP
BZIP2
ZLIB
UNCOMPRESSED
com.aexp.sec.commonutil.KeyState
PreActivated
Activated
Deactivated
Compromised
Destroyed
Suspended
com.aexp.sec.commonutil.crypto.Providers
HIPED supports 2 crypto engines: OPENSSL & BC(Bouncy Castle). 



BC : Bouncy Castle crypto engine. In this mode, HIPED uses Bouncy Castle for all encrypt/decrypt operations
this is a pure java library
OPENSSL : openssl crypto engine. In this mode, HIPED uses openssl for all encrypt/decrypt operations. 
openssl is native library 

hiped still uses Bouncy Castle for computing hashes & for key management, even if OPENSSL is used for encrypt/decrypt operations. 
com.aexp.sec.commonutil.encryption.PaddingMode
PKCS7
NONE: corresponds to the NOPAD mode mentioned in the EncryptionAlgorithms
ZERO
ISO78164
ISO101262
X923


 Only PKCS7 & NONE modes are supported with openssl. To decrypt data encrypted using any other padding mode, you must use the BC provider .

com.aexp.sec.ssaashiped.KeySizes
Valid key sizes 

128: Valid for AES & TDES
192: Valid for TDES 
256: Valid for AES
com.aexp.sec.commonutil.Environment
Environment enumeration has the following valid values:

E1, E2, E3

TEST

E1, E2, E3
Indicates the E1/E2/E3 Server environments

TEST
The enumeration value TEST is used on the Developer desktops, when the KMS API cannot be accessed on the Desktop. In this mode, the HIPED SDK uses:

The Bouncy Castle library for Cryptographic operations, regardless of the chosen provider. This allows applications to test on their laptops without having to install native libraries. 
An XML file ‘vmkeys.xml’ to read the test keys, instead of fetching the test keys from the CKMS server
Setup TEST on your dev machine
Step 1:- Add a property ENVIRONMENT=TEST when initializing hiped class. Remember to delete this property before moving your application to server. You will need to define all the mandatory properties, including the ones for CBIS/APIGEE KMS access. If you haven't yet completed onboarding with KMS, can provide dummy values for CBIS/APIGEE credentials. 

Step 2:- Include the following sample vmkeys.xml file in your Project resources

Step 3:- In the property/code, use the KeyIdentifier value as:-

FPESample for CryptoFPE tests
test for CryptoService tests
testNG for CryptoServiceNG tests 
Note that MK prefix for the key identifier in vmkeys.xml should not be used when referencing the keyId in your code. hiped adds that prefix internally before fetching the key

To use any other value for the KeyIdentifier, replace the value, ‘test’/'testNG/FPESample' in the following xml with the desired KeyIdentifier value. It can be any string <= 16 character size. key-value may be replaced with any valid base64 encoded string corresponding to 16/24/32 byte arrays depending on the chosen algorithm. The key-attribute value may be changed to any other valid EncryptionAlgorithmsNG

Sample vmkeys.xml File
<?xml version="1.0" encoding="UTF-8" standalone="yes"?> 

<keys> 

<key name="MKFPESample"> <!-- encryption key for CryptoFPE class-->  

 <key-value>0s1PVkM10MYHWelSlQLLYEGz6FI8EUDPwKcZKckK6dA=</key-value>  

 <key-attribute name="alg">FF1</key-attribute> 

 <key-attribute name="kp">1</key-attribute> 

 <key-state>Activated</key-state>  

 </key> 

<key name="MKtestNG"> <!-- encryption key for CryptoServiceNG class-->  

 <key-value>apCenm9nbYMLGasPHBnPog==</key-value>  

 <key-attribute name="alg">AES_CTR_NOPAD</key-attribute> 

 <key-state>Activated</key-state>  

 </key> 

<key name="MKtest"> <!-- encryption key for CryptoService class-->  

 <key-value>xGh7659nbh0dGasPHBnPog==</key-value>  

 <key-attribute name="algl">AES_CTR_NOPAD_256</key-attribute> 

 <key-state>Activated</key-state>  

 </key> 

     <key name="HKtest"> <!-- Hash key-->  
 <key-value>123enm9nbYML000PHBnPog==</key-value>  

  <key-state>Activated</key-state>  

 </key> 

</keys>

 

 

Logging
The HIPED classes use SLF4J for logging. They log the following:-

Only the exceptions encountered during cached key refresh, as log4j ERROR messages. 
These errors are logged by hiped, as these occur on background thread. All other exceptions are thrown back to the Client application.
Performance related metrics as log4J INFO messages. Hiped classes log performance metrics for all public cryptographic methods. Metrics logged in nano seconds
Debug traces, as log4J DEBUG messages
Logs added in Hiped version 6.1.0 to aid troubleshooting REST API calls from Hiped
DEBUG logs:-
IDaaS token service JWT token response(already logging) & a SHA3 hash of client id and secret in case of an error encountered. If client id/secret are null or empty, mention that instead of the hash
KMS V1: a SHA3 hash of client id and secret in case of an error encountered. If client id/secret are null or empty, mention that instead of the hash
KMS URL being called will be logged in debug now
INFO logs:-
KMS V1 & V2, IDaaS token service: error code in case of error as well as success. Error message in case of error. 
Configure SLF4J logging to turn on ERROR logging from hiped package com.aexp.sec. This is to ensure that errors occuring on background thread get logged

Turn off INFO and DEBUG logs for com.aexp.sec in production.

Version 6.3.0 onwards, Hiped allows application to completely disable Hiped specific info logs.
Application doing so will no longer see any INFO or DEBUG log from Hiped.
Use below code to disable info log
com.aexp.sec.ssaashiped.Utility.disableInfoLogs();
This should be done at the begining, before any other Hiped code is referenced. This is a one time setup and once disabled, cannot be enabled at runtime.

 



 Standard SLF4J configuration should be used for configuring the HIPED logging.



Sample SLF4J properties
# Root logger option
log4j.rootLogger=ERROR, stdout, file

# Redirect log messages to console
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# Redirect log messages to a log file, support file rolling.
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=../hiped-SDK.log
log4j.appender.file.MaxFileSize=5MB
log4j.appender.file.MaxBackupIndex=10
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n





Web logic support
Weblogic servers use a different httphandler, other than the sun's implementation, wheras prsiv requires use to sun's implementation.

Set property KMS_URL_STREAM_HANDLER= sun.net.www.protocol.https.Handler , to use sun's implementation instead of the default